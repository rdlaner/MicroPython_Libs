"""Multi-state flow tests for PTP state machine.

This module tests state machine traversals through multiple states, verifying
the complete flows of the PTP synchronization protocol including happy paths,
timeout handling, and error conditions.

Generated by copilot with mild review. Hopefully this isn't complete slop.
"""

# Standard imports
import pytest
import time

# Local imports
from mp_libs.time import ptp
from tests.fixtures.time_fixtures import ptp_make_sm


@pytest.fixture(autouse=True)
def cleanup_ptp_timers():
    """Cleanup PTP timers after each test to prevent interference between tests.
    """
    yield
    # After test completes, stop any active PTP timers
    if ptp._ptp_sm is not None:
        ptp._ptp_sm.timer_stop()


def test_begin_event_triggers_sync_req_transmit(ptp_make_sm):
    # Setup
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2)

    # Act
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))

    # Assert
    assert len(tx_msgs) == 1
    pkt = ptp.PtpPacket.deserialize(tx_msgs[-1])
    assert pkt.cmd == ptp.PtpCmd.SYNC_REQ
    assert pkt.payload == 2
    assert isinstance(sm._current_state, ptp.StateSyncReq)


def test_sync_resp_stores_timestamps_and_sends_delay_req(ptp_make_sm):
    # Setup
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))

    # Act
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=1000, rx_ts=2000))

    # Assert
    # first tx is SYNC_REQ, next tx should be DELAY_REQ
    assert len(tx_msgs) >= 2
    assert ptp.PtpPacket.deserialize(tx_msgs[-1]).cmd == ptp.PtpCmd.DELAY_REQ
    assert sm.t1 == 1000 and sm.t2 == 2000
    assert isinstance(sm._current_state, ptp.StateDelayReq)


def test_delay_resp_records_result_and_transitions_to_syncreq_when_more_cycles(ptp_make_sm):
    # Setup: 2 cycles
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=1000, rx_ts=2000))
    t3 = sm.t3

    # Act
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=4000))

    # Assert
    assert len(sm.timestamps) == 1
    assert sm.timestamps[0] == (1000, 2000, t3, 4000)
    assert sm.cycle_count() == 1
    assert isinstance(sm._current_state, ptp.StateSyncReq)
    # Note: transition to SyncReq triggers a SYNC_REQ transmit
    assert ptp.PtpPacket.deserialize(tx_msgs[-1]).cmd == ptp.PtpCmd.SYNC_REQ


def test_delay_resp_transitions_to_ready_when_last_cycle_and_resets(ptp_make_sm):
    # Setup: single cycle
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=1)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=1000, rx_ts=2000))
    t3 = sm.t3

    # Act
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=4000))

    # Assert - after last cycle, transitions to Ready which clears timestamps
    assert isinstance(sm._current_state, ptp.StateReady)
    # entry() of Ready resets timestamps
    assert sm.t1 == 0 and sm.t2 == 0 and sm.t3 == 0 and sm.t4 == 0
    assert sm.timestamps == []  # timestamps cleared on transition to Ready
    # cycle count reset to configured number
    assert sm.cycle_count() == sm.num_sync_cycles


# ------------------------- SM flow tests (multi-state traversals) -------------------------

def test_sm_happy_path_multiple_cycles(ptp_make_sm):
    """Happy path: perform two sync cycles and verify results and final reset."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2)

    # Start first cycle
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=1000, rx_ts=2000))
    t3_1 = sm.t3
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=4000))

    assert sm.timestamps[0] == (1000, 2000, t3_1, 4000)
    assert isinstance(sm._current_state, ptp.StateSyncReq)
    assert sm.cycle_count() == 1

    # Second cycle
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=1100, rx_ts=2100))
    t3_2 = sm.t3

    # Check timestamps before final DELAY_RESP which will trigger Ready and clear them
    assert len(sm.timestamps) == 1  # Only first cycle recorded so far

    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=4100))

    # After last cycle, transitions to Ready which clears timestamps
    assert isinstance(sm._current_state, ptp.StateReady)
    assert sm.timestamps == []  # Cleared on transition to Ready
    assert sm.cycle_count() == sm.num_sync_cycles


def test_sm_delayreq_timeout_decrements_and_transitions_to_syncreq(ptp_make_sm):
    """A timeout in DelayReq decrements cycles and returns to SyncReq to retry."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=3)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=100, rx_ts=200))

    before = sm.cycle_count()
    # We're in DelayReq now; simulate timeout
    assert isinstance(sm._current_state, ptp.StateDelayReq)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_TIMEOUT))

    assert sm.cycle_count() == before - 1
    assert isinstance(sm._current_state, ptp.StateSyncReq)


def test_sm_handles_missing_delay_resp_payload(ptp_make_sm):
    """A DELAY_RESP with None payload should be recorded as a result with None t4.
    Using num_sync_cycles=2 to avoid immediate offset calculation with None t4.
    """
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=5, rx_ts=6))
    t3 = sm.t3

    assert isinstance(sm._current_state, ptp.StateDelayReq)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=None))

    assert sm.timestamps[-1] == (5, 6, t3, None)
    # With more cycles remaining, should transition to SyncReq instead of Ready
    assert isinstance(sm._current_state, ptp.StateSyncReq)


def test_sm_complete_timestamp_exchange_flow(ptp_make_sm):
    """End-to-end happy path: BEGIN -> SYNC_RESP -> DELAY_REQ -> DELAY_RESP.
    Verifies state transitions, transmitted messages, and timestamp ordering at each stage.
    """
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=1)

    # Begin flow: triggers SYNC_REQ send
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))

    # After BEGIN we should have transmitted a SYNC_REQ with payload == num_sync_cycles
    assert len(tx_msgs) >= 1
    pkt0 = ptp.PtpPacket.deserialize(tx_msgs[0])
    assert pkt0.cmd == ptp.PtpCmd.SYNC_REQ
    assert pkt0.payload == 1
    assert isinstance(sm._current_state, ptp.StateSyncReq)

    # Simulate receiving SYNC_RESP from master with payload t1 and measured rx_ts t2
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=100_000, rx_ts=100_100))

    # After processing SYNC_RESP, t1 and t2 must be set, and DelayReq.entry will set t3
    assert sm.t1 == 100_000
    assert sm.t2 == 100_100
    assert isinstance(sm.t3, int)
    t3_val = sm.t3
    assert isinstance(sm._current_state, ptp.StateDelayReq)

    # After entering DelayReq state, a DELAY_REQ message should have been transmitted with t3
    assert len(tx_msgs) >= 2
    pkt1 = ptp.PtpPacket.deserialize(tx_msgs[1])
    assert pkt1.cmd == ptp.PtpCmd.DELAY_REQ
    assert pkt1.payload == t3_val

    # Timestamps should be empty before DELAY_RESP
    assert sm.timestamps == []

    # Simulate master's DELAY_RESP with t4
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=100_200))

    # After DELAY_RESP with last cycle, transitions to Ready which clears timestamps
    # With num_sync_cycles=1, we should transition to Ready
    assert isinstance(sm._current_state, ptp.StateReady)
    # Timestamps cleared on transition to Ready
    assert sm.timestamps == []


def test_sm_syncreq_timeout_recovery_then_success(ptp_make_sm):
    """SYNC_REQ times out, retries, then completes successfully."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=3)

    # Start sync process
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    assert isinstance(sm._current_state, ptp.StateSyncReq)
    assert sm.cycle_count() == 3

    # First SYNC_REQ times out
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_TIMEOUT))
    assert sm.cycle_count() == 2
    assert isinstance(sm._current_state, ptp.StateSyncReq)

    # Second attempt succeeds
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=1000, rx_ts=2000))
    assert isinstance(sm._current_state, ptp.StateDelayReq)
    t3 = sm.t3

    # Complete the exchange
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=3000))
    assert sm.timestamps[0] == (1000, 2000, t3, 3000)
    assert sm.cycle_count() == 1
    assert isinstance(sm._current_state, ptp.StateSyncReq)


def test_sm_delayreq_timeout_recovery_then_success(ptp_make_sm):
    """SYNC_RESP succeeds but DELAY_REQ times out, then completes successfully on retry."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=3)

    # Start and get SYNC_RESP
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=1000, rx_ts=2000))
    assert isinstance(sm._current_state, ptp.StateDelayReq)
    initial_cycle_count = sm.cycle_count()

    # DELAY_REQ times out - should retry SYNC_REQ
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_TIMEOUT))
    assert sm.cycle_count() == initial_cycle_count - 1
    assert isinstance(sm._current_state, ptp.StateSyncReq)

    # Retry succeeds
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=1100, rx_ts=2100))
    assert isinstance(sm._current_state, ptp.StateDelayReq)
    t3 = sm.t3

    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=3100))
    assert sm.timestamps[0] == (1100, 2100, t3, 3100)


def test_sm_multiple_timeouts_then_success(ptp_make_sm):
    """Multiple timeouts at different stages before successful completion."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=5)

    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))

    # First SYNC_REQ timeout
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_TIMEOUT))
    assert sm.cycle_count() == 4
    assert isinstance(sm._current_state, ptp.StateSyncReq)

    # Get SYNC_RESP but DELAY_REQ times out
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=100, rx_ts=200))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_TIMEOUT))
    assert sm.cycle_count() == 3
    assert isinstance(sm._current_state, ptp.StateSyncReq)

    # Another SYNC_REQ timeout
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_TIMEOUT))
    assert sm.cycle_count() == 2

    # Finally succeed
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=1000, rx_ts=2000))
    t3 = sm.t3
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=3000))

    assert len(sm.timestamps) == 1
    assert sm.timestamps[0] == (1000, 2000, t3, 3000)
    assert sm.cycle_count() == 1


def test_sm_complete_cycle_exhaustion_due_to_timeouts(ptp_make_sm):
    """All sync cycles exhausted by timeouts, SM returns to Ready without results."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=3)

    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))

    # Exhaust all 3 cycles with SYNC_REQ timeouts
    for i in range(3):
        assert isinstance(sm._current_state, ptp.StateSyncReq)
        sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_TIMEOUT))

    # Should be back in Ready with no results
    assert isinstance(sm._current_state, ptp.StateReady)
    assert sm.timestamps == []
    assert sm.cycle_count() == sm.num_sync_cycles


def test_sm_first_cycle_success_second_cycle_timeout_exhaustion(ptp_make_sm):
    """First cycle completes, second cycle exhausts remaining attempts with timeouts."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2)

    # First cycle succeeds
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=1000, rx_ts=2000))
    t3_1 = sm.t3
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=3000))

    # After first cycle, still has cycles remaining so doesn't go to Ready
    assert len(sm.timestamps) == 1
    assert sm.timestamps[0] == (1000, 2000, t3_1, 3000)
    assert sm.cycle_count() == 1
    assert isinstance(sm._current_state, ptp.StateSyncReq)

    # Second cycle times out
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_TIMEOUT))

    # Should return to Ready, which clears timestamps
    assert isinstance(sm._current_state, ptp.StateReady)
    assert sm.timestamps == []  # Cleared on transition to Ready
    assert sm.cycle_count() == sm.num_sync_cycles


def test_sm_alternating_success_and_timeout_across_cycles(ptp_make_sm):
    """Multiple cycles with mix of successes and timeouts."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=5)

    # First attempt: SYNC_REQ timeout
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_TIMEOUT))
    assert sm.cycle_count() == 4

    # Second attempt: Success
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=1000, rx_ts=2000))
    t3_1 = sm.t3
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=3000))
    assert len(sm.timestamps) == 1
    assert sm.cycle_count() == 3

    # Third attempt: DELAY_REQ timeout
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=1100, rx_ts=2100))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_TIMEOUT))
    assert sm.cycle_count() == 2

    # Fourth attempt: Success
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=1200, rx_ts=2200))
    t3_2 = sm.t3
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=3200))
    assert len(sm.timestamps) == 2
    assert sm.timestamps[0] == (1000, 2000, t3_1, 3000)
    assert sm.timestamps[1] == (1200, 2200, t3_2, 3200)
    assert sm.cycle_count() == 1


def test_sm_late_sync_resp_after_timeout(ptp_make_sm):
    """SYNC_REQ times out, but then a late SYNC_RESP arrives during retry."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=3)

    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    assert isinstance(sm._current_state, ptp.StateSyncReq)

    # Timeout on first SYNC_REQ
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_TIMEOUT))
    assert sm.cycle_count() == 2
    assert isinstance(sm._current_state, ptp.StateSyncReq)

    # Now a SYNC_RESP arrives (could be from first or second SYNC_REQ)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=1000, rx_ts=2000))
    assert isinstance(sm._current_state, ptp.StateDelayReq)
    t3 = sm.t3

    # Complete successfully
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=3000))
    assert sm.timestamps[0] == (1000, 2000, t3, 3000)


def test_sm_partial_exchange_with_none_payload_then_recovery(ptp_make_sm):
    """Receive DELAY_RESP with None payload, then retry and get valid payload."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=3)

    # First attempt: get None payload
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=1000, rx_ts=2000))
    t3_1 = sm.t3
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=None))

    assert sm.timestamps[0] == (1000, 2000, t3_1, None)
    assert sm.cycle_count() == 2
    assert isinstance(sm._current_state, ptp.StateSyncReq)

    # Second attempt: get valid payload
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=1100, rx_ts=2100))
    t3_2 = sm.t3
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=3100))

    assert len(sm.timestamps) == 2
    assert sm.timestamps[1] == (1100, 2100, t3_2, 3100)


def test_sm_timestamps_accumulate_across_cycles_then_clear_on_ready(ptp_make_sm):
    """Verify timestamps accumulate during cycles but are cleared when returning to Ready."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=3)

    # Initially empty
    assert sm.timestamps == []

    # First cycle
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=100, rx_ts=200))
    t3_1 = sm.t3
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=300))

    assert len(sm.timestamps) == 1
    assert sm.timestamps[0] == (100, 200, t3_1, 300)

    # Second cycle
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=110, rx_ts=210))
    t3_2 = sm.t3
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=310))

    assert len(sm.timestamps) == 2
    assert sm.timestamps[1] == (110, 210, t3_2, 310)

    # Third cycle
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=120, rx_ts=220))
    t3_3 = sm.t3

    # Before final DELAY_RESP, should have 2 timestamps
    assert len(sm.timestamps) == 2

    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=320))

    # After last cycle, transitions to Ready which clears everything
    assert isinstance(sm._current_state, ptp.StateReady)
    assert sm.timestamps == []


def test_sm_timestamps_not_retained_across_sync_sessions(ptp_make_sm):
    """Verify timestamps from a previous sync session don't persist into the next."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2)

    # First sync session
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=100, rx_ts=200))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=300))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=110, rx_ts=210))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=310))

    # Should be in Ready with cleared timestamps
    assert isinstance(sm._current_state, ptp.StateReady)
    assert sm.timestamps == []

    # Start second sync session
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=1000, rx_ts=2000))
    t3_new = sm.t3
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=3000))

    # Should only have one timestamp from current session
    assert len(sm.timestamps) == 1
    assert sm.timestamps[0] == (1000, 2000, t3_new, 3000)


def test_sm_timestamps_cleared_after_timeout_exhaustion(ptp_make_sm):
    """Verify timestamps are cleared when cycles are exhausted due to timeouts."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2)

    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=100, rx_ts=200))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=300))

    # One timestamp recorded
    assert len(sm.timestamps) == 1
    assert sm.cycle_count() == 1

    # Second attempt times out
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_TIMEOUT))

    # Back to Ready, timestamps cleared
    assert isinstance(sm._current_state, ptp.StateReady)
    assert sm.timestamps == []


# ------------------------- Master flow tests -------------------------

def test_sm_master_complete_sync_cycle(ptp_make_sm):
    """Master handles complete sync cycle: SYNC_REQ → SYNC_RESP → DELAY_REQ → DELAY_RESP."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=1)

    # Master receives SYNC_REQ from peripheral
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_REQ))

    # Should transition to SyncResp and send SYNC_RESP with t1
    assert isinstance(sm._current_state, ptp.StateSyncResp)
    assert len(tx_msgs) == 1
    pkt = ptp.PtpPacket.deserialize(tx_msgs[0])
    assert pkt.cmd == ptp.PtpCmd.SYNC_RESP
    assert isinstance(pkt.payload, int)  # t1 timestamp
    t1_sent = pkt.payload

    # Master receives DELAY_REQ from peripheral
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_REQ, rx_ts=5000))

    # Should transition to DelayResp and send DELAY_RESP with t4
    assert isinstance(sm._current_state, ptp.StateDelayResp)
    assert len(tx_msgs) == 2
    pkt = ptp.PtpPacket.deserialize(tx_msgs[1])
    assert pkt.cmd == ptp.PtpCmd.DELAY_RESP
    assert pkt.payload == 5000  # t4 is the rx_ts from DELAY_REQ


def test_sm_master_handles_multiple_sync_cycles(ptp_make_sm):
    """Master handles multiple sync requests sequentially."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=1)

    # First sync cycle
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_REQ))
    assert isinstance(sm._current_state, ptp.StateSyncResp)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_REQ, rx_ts=1000))
    assert isinstance(sm._current_state, ptp.StateDelayResp)

    # Second sync cycle - another SYNC_REQ arrives
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_REQ))
    assert isinstance(sm._current_state, ptp.StateSyncResp)
    assert len(tx_msgs) == 3  # 2 SYNC_RESP, 1 DELAY_RESP

    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_REQ, rx_ts=2000))
    assert isinstance(sm._current_state, ptp.StateDelayResp)
    assert len(tx_msgs) == 4  # 2 SYNC_RESP, 2 DELAY_RESP


def test_sm_master_handles_repeated_sync_req_in_syncresp(ptp_make_sm):
    """Master receives repeated SYNC_REQ messages while in SyncResp state."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=1)

    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_REQ))
    assert isinstance(sm._current_state, ptp.StateSyncResp)
    tx_count_1 = len(tx_msgs)

    # Another SYNC_REQ arrives (maybe packet duplication or new peripheral)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_REQ))

    # Should send another SYNC_RESP, remain in SyncResp
    assert isinstance(sm._current_state, ptp.StateSyncResp)
    assert len(tx_msgs) == tx_count_1 + 1
    pkt = ptp.PtpPacket.deserialize(tx_msgs[-1])
    assert pkt.cmd == ptp.PtpCmd.SYNC_RESP


def test_sm_master_syncresp_to_delayresp_to_syncresp_loop(ptp_make_sm):
    """Master can loop between SyncResp and DelayResp for multiple peripherals."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=1)

    # Peripheral 1
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_REQ))
    assert isinstance(sm._current_state, ptp.StateSyncResp)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_REQ, rx_ts=1000))
    assert isinstance(sm._current_state, ptp.StateDelayResp)

    # Peripheral 2 - new SYNC_REQ
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_REQ))
    assert isinstance(sm._current_state, ptp.StateSyncResp)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_REQ, rx_ts=2000))
    assert isinstance(sm._current_state, ptp.StateDelayResp)

    # Verify all messages sent correctly
    assert len(tx_msgs) == 4  # 2 SYNC_RESP, 2 DELAY_RESP
    msgs = [ptp.PtpPacket.deserialize(msg) for msg in tx_msgs]
    assert msgs[0].cmd == ptp.PtpCmd.SYNC_RESP
    assert msgs[1].cmd == ptp.PtpCmd.DELAY_RESP
    assert msgs[2].cmd == ptp.PtpCmd.SYNC_RESP
    assert msgs[3].cmd == ptp.PtpCmd.DELAY_RESP


# ------------------------- Re-entrant/Concurrent scenario tests -------------------------

def test_sm_begin_while_sync_in_progress_resets(ptp_make_sm):
    """Sending BEGIN while sync is in progress shouldn't restart the process."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2)

    # Start first sync
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=100, rx_ts=200))
    assert isinstance(sm._current_state, ptp.StateDelayReq)

    # Another BEGIN arrives (user/app triggered restart)
    # Since we're in DelayReq, BEGIN is unhandled and logged
    tx_count_before = len(tx_msgs)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))

    # BEGIN is not a valid signal in DelayReq, so state shouldn't change
    assert isinstance(sm._current_state, ptp.StateDelayReq)
    assert len(tx_msgs) == tx_count_before  # No new messages


def test_sm_peripheral_receives_wrong_role_messages(ptp_make_sm):
    """Peripheral in DelayReq receives DELAY_REQ (should be ignored)."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2)

    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=100, rx_ts=200))
    assert isinstance(sm._current_state, ptp.StateDelayReq)

    # Peripheral receives DELAY_REQ (wrong - this is a master message)
    tx_count_before = len(tx_msgs)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_REQ, rx_ts=999))

    # Should be ignored, state unchanged
    assert isinstance(sm._current_state, ptp.StateDelayReq)
    assert len(tx_msgs) == tx_count_before


def test_sm_master_receives_wrong_role_messages(ptp_make_sm):
    """Master in SyncResp receives SYNC_RESP (should be ignored)."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=1)

    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_REQ))
    assert isinstance(sm._current_state, ptp.StateSyncResp)

    # Master receives SYNC_RESP (wrong - this is a peripheral message)
    tx_count_before = len(tx_msgs)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=100, rx_ts=200))

    # Should be ignored, state unchanged
    assert isinstance(sm._current_state, ptp.StateSyncResp)
    assert len(tx_msgs) == tx_count_before


def test_sm_message_arrives_in_unexpected_order(ptp_make_sm):
    """DELAY_RESP arrives before SYNC_RESP (wrong order)."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2)

    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    assert isinstance(sm._current_state, ptp.StateSyncReq)

    # DELAY_RESP arrives while waiting for SYNC_RESP
    tx_count_before = len(tx_msgs)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=999))

    # Should be ignored (unhandled in SyncReq state)
    assert isinstance(sm._current_state, ptp.StateSyncReq)
    assert len(tx_msgs) == tx_count_before


def test_sm_ready_receives_delay_resp(ptp_make_sm):
    """Ready state receives DELAY_RESP message (unexpected)."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=1)

    assert isinstance(sm._current_state, ptp.StateReady)

    # DELAY_RESP arrives in Ready state
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=123))

    # Should be ignored, stay in Ready
    assert isinstance(sm._current_state, ptp.StateReady)
    assert len(tx_msgs) == 0


def test_sm_delay_resp_missing_t4_should_not_apply_offset(ptp_make_sm, mocker):
    """If DELAY_RESP arrives with invalid payload (0), offset should not be applied."""
    sm, _ = ptp_make_sm(num_sync_cycles=1)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=100, rx_ts=200))

    calc_spy = mocker.spy(ptp, "calculate_and_apply_offset")
    offset_spy = mocker.spy(ptp.rtc, "offset")

    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=0))

    # calculate_and_apply_offset runs but should skip applying offset due to sanitization
    assert calc_spy.call_count == 1
    assert offset_spy.call_count == 0


def test_sm_sync_resp_missing_timestamps_should_not_apply_offset(ptp_make_sm, mocker):
    """If SYNC_RESP provides invalid t1/t2 (0), offset should not be applied later."""
    sm, _ = ptp_make_sm(num_sync_cycles=1)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))

    # SYNC_RESP arrives with invalid timestamps (0 treated as invalid)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=0, rx_ts=0))

    calc_spy = mocker.spy(ptp, "calculate_and_apply_offset")
    offset_spy = mocker.spy(ptp.rtc, "offset")

    # Later DELAY_RESP arrives with t4, but t1/t2 were invalid so tuple is sanitized away
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=400))

    # calculate_and_apply_offset runs but should skip applying offset due to sanitization
    assert calc_spy.call_count == 1
    assert offset_spy.call_count == 0


def test_sm_happy_path_applies_offset_to_rtc(ptp_make_sm, mocker):
    """Verify happy path actually applies offset to RTC (not just state transitions)."""
    sm, _ = ptp_make_sm(num_sync_cycles=1)

    # Spy on offset application
    offset_spy = mocker.spy(ptp.rtc, "offset")
    calc_spy = mocker.spy(ptp, "calculate_and_apply_offset")

    # Complete the exchange with valid timestamps
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=1000, rx_ts=2000))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=3000))

    # Should transition to Ready and apply offset
    assert isinstance(sm._current_state, ptp.StateReady)
    assert calc_spy.call_count == 1
    # offset should be called with calculated offset value
    assert offset_spy.call_count == 1


def test_sm_timeout_timer_fires_in_syncreq_state(ptp_make_sm):
    """Verify timeout timer fires and generates SIG_TIMEOUT in SyncReq state."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2, timeout_ms=50)

    # Act - enter SyncReq
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    assert isinstance(sm._current_state, ptp.StateSyncReq)
    assert len(tx_msgs) == 1  # Initial SYNC_REQ sent

    # Wait for timeout to fire
    time.sleep(0.1)  # 100ms > 50ms timeout

    # Assert - cycle count decremented and still in SyncReq
    assert sm.cycle_count() == 1
    assert isinstance(sm._current_state, ptp.StateSyncReq)
    assert len(tx_msgs) == 2  # Retry SYNC_REQ sent


def test_sm_timeout_timer_fires_in_delayreq_state(ptp_make_sm):
    """Verify timeout timer fires and generates SIG_TIMEOUT in DelayReq state."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2, timeout_ms=50)

    # Setup - get to DelayReq
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=100, rx_ts=200))
    assert isinstance(sm._current_state, ptp.StateDelayReq)

    initial_tx_count = len(tx_msgs)

    # Wait for timeout to fire
    time.sleep(0.1)  # 100ms > 50ms timeout

    # Assert - cycle decremented and transitioned to SyncReq
    assert sm.cycle_count() == 1
    assert isinstance(sm._current_state, ptp.StateSyncReq)
    assert len(tx_msgs) > initial_tx_count  # New SYNC_REQ sent on retry


def test_sm_timeout_timer_stops_on_sync_resp(ptp_make_sm, cleanup_ptp_timers):
    """Verify timeout timer stops when SYNC_RESP received before timeout."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2, timeout_ms=100)

    # Setup
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    assert isinstance(sm._current_state, ptp.StateSyncReq)

    # Act - respond quickly, before timeout
    time.sleep(0.02)  # 20ms < 100ms timeout
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=100, rx_ts=200))

    # Assert - transitioned to DelayReq
    assert isinstance(sm._current_state, ptp.StateDelayReq)
    initial_cycle_count = sm.cycle_count()

    # Wait longer than original SyncReq timeout to verify that timer was stopped
    # If the timer was NOT stopped, we wouldn't have transitioned out of SyncReq
    # and would have gotten a timeout. We transitioned to DelayReq which has its
    # own timer, so now we wait less time to avoid DelayReq timeout
    time.sleep(0.05)  # Only 70ms total, less than next timeout of 100ms

    # Assert - should still be in DelayReq with same cycle count
    assert isinstance(sm._current_state, ptp.StateDelayReq)
    assert sm.cycle_count() == initial_cycle_count


def test_sm_timeout_timer_stops_on_delay_resp(ptp_make_sm, mocker, cleanup_ptp_timers):
    """Verify timeout timer stops when DELAY_RESP received before timeout."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=1, timeout_ms=100)
    mocker.patch.object(ptp.rtc, 'offset')

    # Setup - get to DelayReq
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=100, rx_ts=200))
    assert isinstance(sm._current_state, ptp.StateDelayReq)

    # Act - respond quickly, before timeout
    time.sleep(0.02)  # 20ms < 100ms timeout
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=400))

    # Assert - transitioned to Ready
    assert isinstance(sm._current_state, ptp.StateReady)

    # Wait longer than original timeout to verify timer was stopped
    time.sleep(0.15)  # Total 170ms > 100ms

    # Assert - should still be in Ready (not affected by old timer)
    assert isinstance(sm._current_state, ptp.StateReady)


def test_sm_timeout_exhausts_all_cycles(ptp_make_sm):
    """Verify timer correctly exhausts all cycles and returns to Ready."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2, timeout_ms=50)

    # Act - let all cycles timeout
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    assert sm.cycle_count() == 2

    time.sleep(0.1)  # First timeout
    assert sm.cycle_count() == 1
    assert isinstance(sm._current_state, ptp.StateSyncReq)

    time.sleep(0.1)  # Second timeout - should exhaust cycles and transition to Ready

    # Wait a bit for state transition to complete
    time.sleep(0.05)

    # Assert - back to Ready with reset cycle count
    assert isinstance(sm._current_state, ptp.StateReady)
    assert sm.cycle_count() == 2  # Reset on Ready entry


def test_sm_mixed_timeout_and_success_cycles(ptp_make_sm, mocker, cleanup_ptp_timers):
    """Verify timer works correctly with mix of timeouts and successful responses."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=3, timeout_ms=50)
    mocker.patch.object(ptp.rtc, 'offset')

    # Cycle 1 - timeout in SyncReq
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    time.sleep(0.1)
    assert sm.cycle_count() == 2
    assert isinstance(sm._current_state, ptp.StateSyncReq)

    # Cycle 2 - timeout in DelayReq
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=100, rx_ts=200))
    time.sleep(0.1)
    assert sm.cycle_count() == 1
    assert isinstance(sm._current_state, ptp.StateSyncReq)

    # Cycle 3 - success
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=110, rx_ts=210))
    assert isinstance(sm._current_state, ptp.StateDelayReq)

    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=410))
    assert isinstance(sm._current_state, ptp.StateReady)
    assert sm.cycle_count() == 3  # Reset on Ready entry


def test_sm_rapid_transitions_dont_break_timer(ptp_make_sm, mocker, cleanup_ptp_timers):
    """Verify rapid state transitions don't cause timer issues."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2, timeout_ms=50)
    mocker.patch.object(ptp.rtc, 'offset')

    # Rapid sequence without waiting for timeouts
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=100, rx_ts=200))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=400))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=110, rx_ts=210))
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=410))

    # Assert - completed successfully
    assert isinstance(sm._current_state, ptp.StateReady)
    assert len(sm.timestamps) == 0  # Cleared on Ready entry

    # Wait to ensure no stray timer callbacks affect state
    time.sleep(0.1)
    assert isinstance(sm._current_state, ptp.StateReady)
