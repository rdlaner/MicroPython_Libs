"""PTP calculation functions and packet validation tests.

Tests the core mathematical functions that calculate offsets, delays, and process
timestamp data for time synchronization, as well as packet serialization.

Generated by copilot with mild review. Hopefully this isn't complete slop.
"""

# Standard imports
import struct

# Third party imports
import pytest
from pytest_mock import MockerFixture

# Local imports
from mp_libs.time import ptp
from mp_libs.mpy_decimal import DecimalNumber


################################################################################
# Calculation Tests
################################################################################
class TestCalculateOffset:
    """Calculate time offset between peripheral and master clocks."""

    def test_calculate_offset_basic(self):
        """Basic offset calculation with simple values."""
        # t1=100, t2=200, t3=300, t4=400
        # offset = ((t2 - t1) - (t4 - t3)) // 2 = ((200-100) - (400-300)) // 2 = 0
        result = ptp.calculate_offset(100, 200, 300, 400)
        assert result == 0

    def test_calculate_offset_positive(self):
        """Peripheral clock is ahead (positive offset)."""
        # t1=100, t2=250, t3=300, t4=400
        # offset = ((250-100) - (400-300)) // 2 = (150 - 100) // 2 = 25
        result = ptp.calculate_offset(100, 250, 300, 400)
        assert result == 25

    def test_calculate_offset_negative(self):
        """Peripheral clock is behind (negative offset)."""
        # t1=100, t2=150, t3=300, t4=400
        # offset = ((150-100) - (400-300)) // 2 = (50 - 100) // 2 = -25
        result = ptp.calculate_offset(100, 150, 300, 400)
        assert result == -25

    def test_calculate_offset_large_values(self):
        """Offset calculation with large timestamp values."""
        t1 = 1_000_000_000
        t2 = 1_000_000_100
        t3 = 1_000_000_200
        t4 = 1_000_000_300
        # offset = ((100) - (100)) // 2 = 0
        result = ptp.calculate_offset(t1, t2, t3, t4)
        assert result == 0

    def test_calculate_offset_asymmetric_delay(self):
        """Offset calculation with asymmetric network delay."""
        # Scenario: master->peripheral delay = 10, peripheral->master delay = 20
        # t1=100 (master sends SYNC_RESP)
        # t2=110 (peripheral receives SYNC_RESP, 10ms delay)
        # t3=200 (peripheral sends DELAY_REQ)
        # t4=220 (master receives DELAY_REQ, 20ms delay)
        # offset = ((110-100) - (220-200)) // 2 = (10 - 20) // 2 = -5
        result = ptp.calculate_offset(100, 110, 200, 220)
        assert result == -5

    def test_calculate_offset_integer_division(self):
        """Verify integer division rounds down."""
        # offset = ((101-100) - (100-100)) // 2 = 1 // 2 = 0
        result = ptp.calculate_offset(100, 101, 100, 100)
        assert result == 0

        # offset = ((103-100) - (100-100)) // 2 = 3 // 2 = 1
        result = ptp.calculate_offset(100, 103, 100, 100)
        assert result == 1


class TestCalculateDelay:
    """Calculate round-trip network delay."""

    def test_calculate_delay_symmetric(self):
        """Symmetric delay calculation."""
        # t1=100, t2=120, t3=200, t4=220
        # delay = ((120-100) + (220-200)) // 2 = (20 + 20) // 2 = 20
        result = ptp.calculate_delay(100, 120, 200, 220)
        assert result == 20

    def test_calculate_delay_asymmetric(self):
        """Asymmetric delay calculation."""
        # t1=100, t2=110, t3=200, t4=230
        # delay = ((110-100) + (230-200)) // 2 = (10 + 30) // 2 = 20
        result = ptp.calculate_delay(100, 110, 200, 230)
        assert result == 20

    def test_calculate_delay_zero(self):
        """Zero delay (theoretical case)."""
        result = ptp.calculate_delay(100, 100, 200, 200)
        assert result == 0

    def test_calculate_delay_large_values(self):
        """Delay calculation with large timestamp values."""
        t1 = 1_000_000_000
        t2 = 1_000_000_050
        t3 = 2_000_000_000
        t4 = 2_000_000_070
        # delay = (50 + 70) // 2 = 60
        result = ptp.calculate_delay(t1, t2, t3, t4)
        assert result == 60


class TestProcessOffsets:
    """Process multiple offset measurements and remove outliers."""

    def test_process_offsets_clean_data(self):
        """Processing clean data without outliers."""
        offsets = [100, 101, 102, 100, 101]
        result = ptp.process_offsets(offsets)
        # Average should be around 100-101
        assert 100 <= result <= 102

    def test_process_offsets_with_outliers(self):
        """Processing data with outliers that should be removed."""
        offsets = [100, 100, 101, 100, 101, 500, -500]  # 500 and -500 are outliers
        result = ptp.process_offsets(offsets)
        # Should be close to 100 after outlier removal
        assert 99 <= result <= 102

    def test_process_offsets_single_value(self):
        """Processing single offset value."""
        offsets = [50]
        result = ptp.process_offsets(offsets)
        assert result == 50

    def test_process_offsets_all_same(self):
        """Processing identical offset values."""
        offsets = [100, 100, 100, 100]
        result = ptp.process_offsets(offsets)
        assert result == 100

    def test_process_offsets_negative_values(self):
        """Processing negative offset values."""
        offsets = [-50, -51, -50, -52, -50]
        result = ptp.process_offsets(offsets)
        # Should be around -50 to -51
        assert -52 <= result <= -49

    def test_process_offsets_decimal_numbers(self):
        """Processing DecimalNumber objects."""
        offsets = [DecimalNumber(100), DecimalNumber(101), DecimalNumber(100)]
        result = ptp.process_offsets(offsets)
        assert 99 <= result <= 102

    def test_process_offsets_converts_ints_to_decimal(self):
        """Verify ints are converted to DecimalNumber internally."""
        offsets = [100, 101, 102]
        result = ptp.process_offsets(offsets)
        assert isinstance(result, int)


class TestCalculateAndApplyOffset:
    """Calculate offset from timestamp sets and apply to RTC."""

    def test_calculate_and_apply_offset_single_cycle(self, mocker: MockerFixture):
        """Calculate and apply offset from single sync cycle."""
        mock_offset = mocker.patch.object(ptp.rtc, 'offset')
        timestamps = [(100, 200, 300, 400)]  # offset = 0

        result = ptp.calculate_and_apply_offset(timestamps)

        assert result == 0
        mock_offset.assert_called_once_with(0)

    def test_calculate_and_apply_offset_multiple_cycles(self, mocker: MockerFixture):
        """Calculate and apply average offset from multiple cycles."""
        mock_offset = mocker.patch.object(ptp.rtc, 'offset')
        # Three cycles with offsets: 10, 10, 10 -> average 10
        timestamps = [
            (100, 120, 200, 220),  # offset = 0
            (100, 121, 200, 220),  # offset = 0 (rounded down from 0.5)
            (100, 120, 200, 220),  # offset = 0
        ]

        result = ptp.calculate_and_apply_offset(timestamps)

        assert result == 0
        mock_offset.assert_called_once_with(0)

    def test_calculate_and_apply_offset_with_outliers(self, mocker: MockerFixture):
        """Calculate offset with outliers that should be filtered."""
        mock_offset = mocker.patch.object(ptp.rtc, 'offset')
        # Most cycles show offset ~50, but one outlier at 500
        timestamps = [
            (100, 200, 300, 400),    # offset = 0
            (100, 201, 300, 400),    # offset = 0 (rounded from 0.5)
            (100, 200, 300, 400),    # offset = 0
            (100, 700, 300, 400),    # offset = 300 (outlier)
        ]

        result = ptp.calculate_and_apply_offset(timestamps)

        # Should be close to 0 after outlier removal
        assert -1 <= result <= 1
        assert mock_offset.called

    def test_calculate_and_apply_offset_negative(self, mocker: MockerFixture):
        """Calculate and apply negative offset."""
        mock_offset = mocker.patch.object(ptp.rtc, 'offset')
        # offset = ((150-100) - (400-300)) // 2 = -25
        timestamps = [(100, 150, 300, 400)]

        result = ptp.calculate_and_apply_offset(timestamps)

        assert result == -25
        mock_offset.assert_called_once_with(-25)

    def test_calculate_and_apply_offset_all_invalid_returns_zero(self, mocker: MockerFixture):
        """All tuples invalid (contain 0) -> skip and return 0 without applying."""
        mock_offset = mocker.patch.object(ptp.rtc, 'offset')
        timestamps = [
            (0, 0, 0, 0),
            (0, 123, 456, 789),
            (10, 0, 20, 30),
        ]

        result = ptp.calculate_and_apply_offset(timestamps)

        assert result == 0
        mock_offset.assert_not_called()

    def test_calculate_and_apply_offset_mixed_valid_and_invalid_uses_valid_only(self, mocker: MockerFixture):
        """Mixed tuples: invalid ones discarded, offset computed from valid ones only."""
        mock_offset = mocker.patch.object(ptp.rtc, 'offset')
        # Valid tuple offset = ((200-100)-(400-300))//2 = 0
        timestamps = [
            (0, 0, 0, 0),              # invalid
            (100, 200, 300, 400),      # valid -> offset 0
            (50, 0, 60, 70),           # invalid
        ]

        result = ptp.calculate_and_apply_offset(timestamps)

        assert result == 0
        mock_offset.assert_called_once_with(0)

    def test_calculate_and_apply_offset_empty_list_returns_zero(self, mocker: MockerFixture):
        """Empty input should return 0 and not apply offset."""
        mock_offset = mocker.patch.object(ptp.rtc, 'offset')

        result = ptp.calculate_and_apply_offset([])

        assert result == 0
        mock_offset.assert_not_called()


################################################################################
# Packet Serialization Tests
################################################################################
class TestPtpPacket:
    """PTP packet serialization and deserialization."""

    def test_packet_serialize_deserialize_roundtrip(self):
        """Serialize and deserialize should be reversible."""
        original = ptp.PtpPacket(ptp.PtpCmd.SYNC_REQ, 12345)
        serialized = original.serialize()
        deserialized = ptp.PtpPacket.deserialize(serialized)

        assert deserialized.cmd == ptp.PtpCmd.SYNC_REQ
        assert deserialized.payload == 12345

    def test_packet_all_message_types(self):
        """Test serialization of all message types."""
        for msg_type in [ptp.PtpCmd.SYNC_REQ, ptp.PtpCmd.SYNC_RESP,
                         ptp.PtpCmd.DELAY_REQ, ptp.PtpCmd.DELAY_RESP]:
            packet = ptp.PtpPacket(msg_type, 999)
            serialized = packet.serialize()
            deserialized = ptp.PtpPacket.deserialize(serialized)

            assert deserialized.cmd == msg_type
            assert deserialized.payload == 999

    def test_packet_payload_zero(self):
        """Payload can be zero."""
        packet = ptp.PtpPacket(ptp.PtpCmd.SYNC_REQ, 0)
        serialized = packet.serialize()
        deserialized = ptp.PtpPacket.deserialize(serialized)

        assert deserialized.payload == 0

    def test_packet_payload_large_value(self):
        """Payload with large value."""
        large_value = 2**63 - 1  # Max signed 64-bit int
        packet = ptp.PtpPacket(ptp.PtpCmd.DELAY_RESP, large_value)
        serialized = packet.serialize()
        deserialized = ptp.PtpPacket.deserialize(serialized)

        assert deserialized.payload == large_value

    def test_packet_deserialize_invalid_size(self):
        """Deserialize fails with wrong size."""
        with pytest.raises(ptp.PtpPacketError, match="Invalid size"):
            ptp.PtpPacket.deserialize(b"too short")

    def test_packet_deserialize_invalid_delimiter(self):
        """Deserialize fails with wrong delimiter."""
        # Create a packet with wrong delimiter
        bad_data = b"<BAD>" + b"\x00" * (ptp.PTP_PACKET_SIZE_BYTES - 5)

        with pytest.raises(ptp.PtpPacketError, match="Invalid packet delim"):
            ptp.PtpPacket.deserialize(bad_data)

    def test_packet_deserialize_invalid_message_type(self):
        """Deserialize fails with invalid message type."""
        # Create packet with invalid message type (255 is not a valid PTP message type)
        bad_data = struct.pack(
            ptp.PTP_PACKET_FORMAT_STR,
            ptp.PTP_PACKET_DELIM,
            255,  # Invalid message type (but valid byte)
            123   # Valid payload
        )

        with pytest.raises(ptp.PtpPacketError, match="invalid cmd"):
            ptp.PtpPacket.deserialize(bad_data)

    def test_packet_deserialize_corrupted_data(self):
        """Deserialize fails with corrupted data."""
        # Completely random bytes of correct size
        corrupted = b"\xFF" * ptp.PTP_PACKET_SIZE_BYTES

        with pytest.raises(ptp.PtpPacketError):
            ptp.PtpPacket.deserialize(corrupted)

    def test_packet_properties(self):
        """Test packet property accessors."""
        packet = ptp.PtpPacket(ptp.PtpCmd.SYNC_RESP, 54321)

        assert packet.cmd == ptp.PtpCmd.SYNC_RESP
        assert packet.payload == 54321

    def test_is_ptp_msg_valid(self):
        """is_ptp_msg returns True for valid packet."""
        packet = ptp.PtpPacket(ptp.PtpCmd.SYNC_REQ, 100)
        serialized = packet.serialize()

        assert ptp.is_ptp_msg(serialized) is True

    def test_is_ptp_msg_invalid(self):
        """is_ptp_msg returns False for invalid data."""
        assert ptp.is_ptp_msg(b"not a packet") is False
        assert ptp.is_ptp_msg(b"\x00" * 100) is False
