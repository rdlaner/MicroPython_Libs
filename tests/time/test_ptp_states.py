"""State-level unit tests for PTP state machine states

Generated by copilot with mild review. Hopefully this isn't complete slop.
"""

# Standard imports
import pytest

# Local imports
from mp_libs.time import ptp
from tests.fixtures.time_fixtures import ptp_make_sm


# ------------------------- StateReady tests -------------------------
def test_state_ready_entry_resets_cycle_and_timestamps(ptp_make_sm):
    sm, _ = ptp_make_sm(num_sync_cycles=4)

    # entry has already been called by start()
    assert sm.cycle_count() == 4
    assert sm.t1 == 0 and sm.t2 == 0 and sm.t3 == 0 and sm.t4 == 0


def test_state_ready_initializes_state_machine_correctly(ptp_make_sm):
    """Verify state machine initializes in Ready state with cleared timestamps."""
    sm, _ = ptp_make_sm(num_sync_cycles=3)

    # Assert initial state
    assert sm.cycle_count() == 3
    assert sm.t1 == 0 and sm.t2 == 0 and sm.t3 == 0 and sm.t4 == 0
    assert sm.timestamps == []
    assert isinstance(sm._current_state, ptp.StateReady)


def test_state_ready_process_begin_transitions_to_syncreq(ptp_make_sm):
    sm, _ = ptp_make_sm(num_sync_cycles=2)

    # Act
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))

    # Assert
    assert isinstance(sm._current_state, ptp.StateSyncReq)


def test_state_ready_process_sync_req_transitions_to_syncresp(ptp_make_sm):
    sm, _ = ptp_make_sm(num_sync_cycles=2)

    # Act
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_REQ))

    # Assert
    assert isinstance(sm._current_state, ptp.StateSyncResp)


# ------------------------- StateSyncReq tests -------------------------
def test_state_syncreq_entry_goes_to_ready_when_cycle_zero(ptp_make_sm):
    sm, _ = ptp_make_sm(num_sync_cycles=1)

    # Make cycles zero and then transition into SyncReq
    sm._cycle_count = 0
    sm.transition(sm._current_state, ptp.StateSyncReq())

    assert isinstance(sm._current_state, ptp.StateReady)
    # Ready.entry resets the configured cycle count
    assert sm.cycle_count() == sm.num_sync_cycles


def test_state_syncreq_entry_sends_sync_req_when_cycles_nonzero(ptp_make_sm):
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=3)

    # Make sure we have cycles remaining and transition
    sm._cycle_count = 2
    sm.transition(sm._current_state, ptp.StateSyncReq())

    assert len(tx_msgs) == 1
    pkt = ptp.PtpPacket.deserialize(tx_msgs[-1])
    assert pkt.cmd == ptp.PtpCmd.SYNC_REQ
    assert pkt.payload == 3  # payload is configured num_sync_cycles


def test_state_syncreq_process_timeout_decrements_and_retries(ptp_make_sm):
    sm, _ = ptp_make_sm(num_sync_cycles=3)
    sm._cycle_count = 2
    sm.transition(sm._current_state, ptp.StateSyncReq())

    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_TIMEOUT))

    assert sm.cycle_count() == 1
    assert isinstance(sm._current_state, ptp.StateSyncReq)


def test_state_syncreq_process_sync_resp_stores_timestamps_and_enters_delayreq(ptp_make_sm):
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2)
    sm._cycle_count = 2
    sm.transition(sm._current_state, ptp.StateSyncReq())

    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_RESP, payload_ts=10, rx_ts=20))

    assert sm.t1 == 10 and sm.t2 == 20
    assert isinstance(sm._current_state, ptp.StateDelayReq)


def test_state_syncreq_timeout_exhausts_cycles_and_returns_to_ready(ptp_make_sm):
    """When cycle count reaches zero after timeout, StateSyncReq transitions to Ready."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=1)
    sm.transition(sm._current_state, ptp.StateSyncReq())
    sm._cycle_count = 1

    # Simulate timeout which should decr cycles to 0 and then entry to SyncReq will redirect to Ready
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_TIMEOUT))

    assert isinstance(sm._current_state, ptp.StateReady)
    assert sm.cycle_count() == sm.num_sync_cycles
    assert sm.timestamps == []


def test_state_syncreq_tx_failure_does_not_terminate_sm(ptp_make_sm):
    """If tx function fails, SM should remain operational in expected state."""
    def failing_tx(data, **kwargs):
        return False

    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2, tx_fxn=failing_tx)
    sm._cycle_count = 2
    sm.transition(sm._current_state, ptp.StateSyncReq())

    assert isinstance(sm._current_state, ptp.StateSyncReq)
    assert len(tx_msgs) >= 1


# ------------------------- StateSyncResp tests -------------------------
def test_state_syncresp_entry_sends_sync_resp(ptp_make_sm):
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2)

    sm.transition(sm._current_state, ptp.StateSyncResp())

    assert len(tx_msgs) == 1
    pkt = ptp.PtpPacket.deserialize(tx_msgs[-1])
    assert pkt.cmd == ptp.PtpCmd.SYNC_RESP
    assert isinstance(pkt.payload, int)


def test_state_syncresp_process_sync_req_sends_sync_resp_again(ptp_make_sm):
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2)
    sm.transition(sm._current_state, ptp.StateSyncResp())

    before = len(tx_msgs)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_REQ))

    assert len(tx_msgs) == before + 1
    assert ptp.PtpPacket.deserialize(tx_msgs[-1]).cmd == ptp.PtpCmd.SYNC_RESP


def test_state_syncresp_process_delay_req_stores_t4_and_transitions_to_delayresp(ptp_make_sm):
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2)
    sm.transition(sm._current_state, ptp.StateSyncResp())

    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_REQ, rx_ts=7777))

    assert sm.t4 == 7777
    assert isinstance(sm._current_state, ptp.StateDelayResp)
    # DelayResp.entry should have sent DELAY_RESP with t4
    assert ptp.PtpPacket.deserialize(tx_msgs[-1]).cmd == ptp.PtpCmd.DELAY_RESP
    assert ptp.PtpPacket.deserialize(tx_msgs[-1]).payload == 7777


# ------------------------- StateDelayReq tests -------------------------
def test_state_delayreq_entry_sends_delay_req_and_sets_t3(ptp_make_sm):
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2)
    sm.transition(sm._current_state, ptp.StateDelayReq())

    assert len(tx_msgs) == 1
    assert ptp.PtpPacket.deserialize(tx_msgs[-1]).cmd == ptp.PtpCmd.DELAY_REQ
    assert isinstance(sm.t3, int)


def test_state_delayreq_process_timeout_decrements_and_transitions_to_syncreq(ptp_make_sm):
    sm, _ = ptp_make_sm(num_sync_cycles=2)
    sm._cycle_count = 2
    sm.transition(sm._current_state, ptp.StateDelayReq())

    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_TIMEOUT))

    assert sm.cycle_count() == 1
    assert isinstance(sm._current_state, ptp.StateSyncReq)


def test_state_delayreq_process_delay_resp_records_result_and_handles_last_and_non_last(ptp_make_sm):
    # Non-last cycle case
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2)
    sm._cycle_count = 2
    sm.transition(sm._current_state, ptp.StateDelayReq())
    t3 = sm.t3

    sm.t1 = 100
    sm.t2 = 200
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=4000))

    assert sm.timestamps[-1] == (100, 200, t3, 4000)
    assert sm.cycle_count() == 1
    assert isinstance(sm._current_state, ptp.StateSyncReq)

    # Last cycle case - transitions to Ready which clears timestamps
    sm2, _ = ptp_make_sm(num_sync_cycles=1)
    sm2._cycle_count = 1
    sm2.transition(sm2._current_state, ptp.StateDelayReq())
    sm2.t1 = 10
    sm2.t2 = 20
    t3_before = sm2.t3
    sm2.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=55))

    # After last cycle, transitions to Ready which clears timestamps
    assert isinstance(sm2._current_state, ptp.StateReady)
    assert sm2.timestamps == []  # Cleared on transition to Ready
    assert sm2.cycle_count() == sm2.num_sync_cycles


def test_state_delayreq_process_delay_resp_handles_missing_payload_gracefully(ptp_make_sm):
    # payload_ts None should still record the result (edge case)
    # Using num_sync_cycles=2 to avoid immediate offset calculation with None t4
    sm, _ = ptp_make_sm(num_sync_cycles=2)
    sm._cycle_count = 2
    sm.transition(sm._current_state, ptp.StateDelayReq())
    sm.t1 = 7
    sm.t2 = 14

    t3_before = sm.t3
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_DELAY_RESP, payload_ts=None))

    assert sm.timestamps[-1] == (7, 14, t3_before, None)


# ------------------------- StateDelayResp tests -------------------------
def test_state_delayresp_entry_sends_delay_resp_with_t4(ptp_make_sm):
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=1)
    sm.t4 = 0xABC
    sm.transition(sm._current_state, ptp.StateDelayResp())

    assert ptp.PtpPacket.deserialize(tx_msgs[-1]).cmd == ptp.PtpCmd.DELAY_RESP
    assert ptp.PtpPacket.deserialize(tx_msgs[-1]).payload == 0xABC


def test_state_delayresp_process_sync_req_transitions_to_syncresp(ptp_make_sm):
    sm, _ = ptp_make_sm(num_sync_cycles=1)
    sm.transition(sm._current_state, ptp.StateDelayResp())

    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_SYNC_REQ))

    assert isinstance(sm._current_state, ptp.StateSyncResp)


# ------------- Misc and edge helpers -----------------
def test_cycle_count_decr_never_negative(ptp_make_sm):
    sm, _ = ptp_make_sm(num_sync_cycles=1)
    sm._cycle_count = 0
    sm.cycle_count_decr()
    assert sm.cycle_count() == 0


def test_tx_failure_does_not_break_state(ptp_make_sm):
    # Simulate a transmit function that reports failure (returns False)
    def failing_tx(data, **kwargs):
        return False

    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2, tx_fxn=failing_tx)
    sm.process_evt(ptp.PtpEvt(ptp.PtpSig.SIG_BEGIN))

    # State should still be SyncReq and at least one tx attempt should have occurred
    assert isinstance(sm._current_state, ptp.StateSyncReq)
    assert len(tx_msgs) >= 1


# ------------- Unhandled/Invalid Events -----------------
@pytest.mark.parametrize("state_cls", [
    ptp.StateReady,
    ptp.StateSyncReq,
    ptp.StateSyncResp,
    ptp.StateDelayReq,
    ptp.StateDelayResp,
])
def test_state_unhandled_signal_is_ignored(state_cls, ptp_make_sm):
    """Verify that unhandled/unknown signals don't change state or cause errors."""
    sm, tx_msgs = ptp_make_sm(num_sync_cycles=2)
    sm.transition(sm._current_state, state_cls())

    # Snapshot state before
    before_state = type(sm._current_state)
    before_timestamps = (sm.t1, sm.t2, sm.t3, sm.t4)
    before_cycle = sm.cycle_count()
    before_timestamps_list = list(sm.timestamps)
    before_tx_len = len(tx_msgs)

    # Act: send an unknown signal value (not in PtpSig)
    sm.process_evt(ptp.PtpEvt(999))

    # Assert: no state change, no timestamp change, no new tx, results unchanged
    assert type(sm._current_state) is before_state
    assert (sm.t1, sm.t2, sm.t3, sm.t4) == before_timestamps
    assert sm.cycle_count() == before_cycle
    assert sm.timestamps == before_timestamps_list
    assert len(tx_msgs) == before_tx_len
